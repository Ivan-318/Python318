Класс
class НазваниеКласса:
	свойства (поля, переменные)
		- статические -> за пределами init
		- динамические (свойства класса) -> внутри init
	методы (функции)
		- статические (@staticmethod -> def method()) -> это функция внутри класса
		- экземпляра класса (def method(self))
		- методы классов (@classmethod -> def method(cls))
	атрибуты = свойства + методы

Магические методы (dunder-методы) - отрабатывают каждый раз при создании экземпляра класса

Чтобы язык считался объектно-ориентированым, он должен соблюдать следующие парадигмы (уметь реализовывать свойства):
- инкапсуляция
- наследование
- полиморфизм (много форм одного и того же метода) - способность системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта (у одного действия несколько реализаций, в зависимости от того, с каким классом ведётся работа)

Модификаторы доступа:
public - self.name - открытый доступ
protected - self._name - используется при наследовании
private - self.__name - защищённый доступ (нельзя получить из вне)

Наследование

родительский (базовый, основной, суперкласс) класс
	дочерний (наследник, подкласс) класс
В Python не преветствуется дублирование кода(например, одинакового инициализатора):
DRY (Don`t Repeate Yourself) -  не повторяйся! -> помагает наследование

# Модули из стандартной библиотеки Python
# marshal - для чтения и записи bytecode модулей Python; поддерживал старое расширение (.pyc)
# pickle - формат Python, только все типы данных Python
# json - на любом ЯП

Методы для работы с pickle и json:

обращение к модулю.dump() - сохраняет данные в открытый файл
dumps() - сохраняет данные в строку (в оперативной памяти)

	- считать из файла:
load() - считывает данные из открытого файла
loads() - считывает данные из строки
"20": null, // у формата json все ключи строка

Парсинг сайтов 

Установка модулей

pip install requests -> для получения доступа к json-объекту; отправки http-запросов

csv (Comma Separated Values - переменные, разделённые запятыми или ";"-> у меня) - лёгкий текстовый документ, легко передаётся по сети. Позволяет наполнять себя большими объёмами данными для их передачи, хранения(интернет-маназин с большим объёмом ресурсов)
data.csv -> может читать Excel

Методы чтения .csv в Python:
reader => []
DictReader => {} - работает с данными как с элементами словаря

Методы для записи .csv из Python:
write => []
DictWrite => {} - работает с данными как с элементами словаря

запись csv компактнее JSON, csv новее JSON

pip install bs4 (beautifulsoup4) -> для извлечения *.html, *.htm. в Python нет тэгов, чтобы распознавать html-разметку

pip install lxml

Паттерны -> картинка - шаблоны проектирования
MVC -> Model View Controller - разделяет логику приложения на три части

Введение в теорию баз данных, занятие 37.

SQL - язык структурированных запросов
SQlite
*.db, *.sqlite, *.db3, *.sqlite3

SELECT [ALL | DISTINCT] * | столбец [, столбец_N] -> ALL-ПО УМОЛЧАНИЮ; DISTINCT-ТОЛЬКО УНИКАЛЬНЫЕ ЭЛЕМЕНТЫ
FROM таблица_1 [, таблица_N]
WHERE условие
	=, ==, <>, !=, >, >=, <, <=
	AND, OR
	выражение [NOT] BETWEEN начальное_значение AND кончное_значение
	выражение [NOT] LIKE шаблон_строки:
		% - любое количество символов
		_ - любой одиночный символ 
	выражение [NOT] GLOB регулярное выражение:
		* - любое кол-во символов
		? - соответствует одному символу
		. - любой одиночный символ
		[символы] - один из заданных символов, например [abc] - либо a, либо b, либо c
		[начальный_символ-конечный_символ] - один из диапазона
		[a-z0-9]
		[^...] - инвертирование, любой, кроме заданных [^abc], [^0-9] 
	выражение IS [NOT] NULL - является пустым
	выражение [NOT] IN(набор значений | выражение)
GROUP BY - (группировать по)	имя_столбца
HAVING (условие) - для сравнение функции агрегирования
ORDER BY столбец_1 | номер столбца [ASC | DESC] - (сортировки по возрастанию (можно не указывать) и убыванию соответственно) [, столбец_N]
LIMIT кол-во_строк OFFSET (смещение)
	LIMIT [смещение,] кол-во_строк

[Па-Ле]
Добавление, изменение, удаление записей в таблице.
ISERT
UPDATE
DELETE


ISERT INTO имя_таблицы [(столбец_1, столбец_N)]
VALUES (столбец_1, столбец_N)

ISERT INTO имя_таблицы [(столбец_1, столбец_N)]
SELECT [(столбец_1, столбец_N)]
FROM имя_таблицы(из которой берём данные)
WHERE условие

UPDATE имя_таблицы
SET столбец_1=значение_1, столбец_N=значение_N
WHERE условие

DELETE FROM имя_таблицы
WHERE условие

Логическая база данных -> первые разработчики
Физическая база данных -> вторые разработчики

Декартовое произвнедение - все возможные комбинации одной строки одной таблицы с 
каждой строкой другой таблицы -> получаем избыточные результаты,когда не установлены связи

Функции агрегирования - результат определённого столбца
SUM	 только с числами
AVG	 только с числами
COUNT	любые типы дынных
MIN		любые типы дынных
MAX		любые типы дынных

Работа с подзапросами (возможность создания внутреннего запроса, внутренний или вложенных запрос)

Однострочный подзапрос -> когда вложенный запрос возвращает одно значение, используются любые операторы сравнения:
	=, <>, >=, <=, >, <
	
Многострочный подзапрос
	IN, NOT IN
	
Пример:
SELECT s.com
FROM Salespeople s, Customers c
WHERE s.snum=c.snum AND c.city="Rome";

SELECT com
FROM Salespeople
WHERE snum IN 
    (SELECT snum --(1003, 1004, 1000)
    FROM Customers
    WHERE city="Rome" AND Salespeople.sname="Axelrod");

/*SELECT amt
FROM Orders
WHERE snum IN --1007
    (SELECT snum
    FROM Salespeople
    WHERE sname="Rifkin");*/



